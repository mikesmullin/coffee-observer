// Generated by CoffeeScript 1.6.3
var CoffeeObserver, async, child_process, gaze, growl, path, throttledGrowl, _;

_ = require('underscore');

async = require('async2');

path = require('path');

path.xplat = function(b, s) {
  return path.join.apply(null, s ? [b].concat(s.split('/')) : b.split('/'));
};

growl = require('growl');

gaze = require('gaze');

child_process = require('child_process');

throttledGrowl = _.throttle(growl, 3 * 1000, {
  trailing: false
});

module.exports = CoffeeObserver = (function() {
  function CoffeeObserver() {
    this._titles = {};
    this._color_index = 0;
    this.colors = ['\u001b[33m', '\u001b[34m', '\u001b[35m', '\u001b[36m', '\u001b[31m', '\u001b[32m', '\u001b[1m\u001b[33m', '\u001b[1m\u001b[34m', '\u001b[1m\u001b[35m', '\u001b[1m\u001b[36m', '\u001b[1m\u001b[31m', '\u001b[1m\u001b[32m'];
    this.node_child = null;
  }

  CoffeeObserver.prototype.notify = function(title, msg, image, err, show) {
    var prefix;
    if (typeof this._titles[title] === 'undefined') {
      this._titles[title] = this._color_index++;
    }
    if (err && typeof msg === 'object' && typeof msg.stack !== 'undefined') {
      msg = msg.stack;
    }
    if (show) {
      throttledGrowl(msg, {
        image: path.xplat(__dirname, "/../images/" + image + ".png"),
        title: title
      });
    }
    msg = ('' + msg).replace(/[\r\n]+$/, '');
    prefix = "" + this.colors[this._titles[title]] + title + ":\u001b[0m ";
    console.log("" + prefix + (msg.replace(/\n/g, "\n" + prefix)));
    return "" + title + ": " + msg;
  };

  CoffeeObserver.prototype.child_process_loop = function(collection, title, cwd, cmd, args, env) {
    var child, last_start,
      _this = this;
    last_start = new Date();
    child = child_process.spawn(cmd, args, {
      cwd: cwd,
      env: env
    });
    child.stdout.on('data', function(stdout) {
      return _this.notify(title, '' + stdout, 'pending', false, false);
    });
    child.stderr.on('data', function(stderr) {
      return _this.notify(title, '' + stderr, 'failure', true, true);
    });
    child.on('exit', function(code) {
      var uptime;
      uptime = new Date() - last_start;
      _this.notify(title, "exit with code " + (code || 0) + " (uptime: " + (uptime / 1000) + "sec). will restart...", 'pending', false, false);
      if (uptime < 2 * 1000) {
        _this.notify(title, 'waiting 3sec to prevent flapping due to short uptime...', 'pending', false, false);
        return async.delay(3 * 1000, function() {
          return _this.child_process_loop(collection, title, cwd, cmd, args, env);
        });
      } else {
        return _this.child_process_loop(collection, title, cwd, cmd, args, env);
      }
    });
    this.notify(title, 'spawned new instance', 'success', false, false);
    collection[title] = child;
    return child;
  };

  CoffeeObserver.prototype.watch = function() {
    var a, cb, glob, globs, k, kk, suffix, title, _results;
    a = arguments;
    cb = a[a.length - 1];
    if (a.length === 3) {
      globs = [
        {
          "in": [''],
          out: ''
        }
      ];
      title = a[0], suffix = a[1];
    } else if (a.length === 4) {
      title = a[0], globs = a[1], suffix = a[2];
    }
    _results = [];
    for (k in globs) {
      glob = globs[k];
      if (typeof glob["in"] === 'string') {
        glob["in"] = [glob["in"]];
      }
      _results.push((function() {
        var _results1,
          _this = this;
        _results1 = [];
        for (kk in glob["in"]) {
          _results1.push((function(glob) {
            _this.notify('gaze', "watching " + (glob["in"] + glob.suffix), 'pending', false, false);
            return gaze(path.join(process.cwd(), glob["in"] + glob.suffix), function(err, watcher) {
              if (err) {
                _this.notify('gaze', err, 'failure', true, false);
              }
              return  this.on('changed', function(file) {
                var rel_in;
                rel_in = path.relative(path.join(process.cwd(), glob["in"]), file);
                glob.out || (glob.out = rel_in);
                return cb({
                  title: title,
                  infile: path.relative(process.cwd(), file),
                  outfile: path.join(glob.out, rel_in),
                  inpath: glob["in"],
                  outpath: glob.out
                });
              });
            });
          })({
            "in": glob["in"][kk] && path.xplat(glob["in"][kk]),
            out: glob.out && path.xplat(glob.out),
            suffix: glob.suffix || suffix
          }));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  return CoffeeObserver;

})();
